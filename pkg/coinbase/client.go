package coinbase

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/alpine-hodler/sdk/internal/client"
	"github.com/alpine-hodler/sdk/internal/env"
	"github.com/alpine-hodler/sdk/internal/log"
	"github.com/alpine-hodler/sdk/pkg/websocket"
)

// C is the coinbase pro client
type C struct {
	client.Parent

	client     http.Client
	key        string
	passphrase string
	secret     string
	url        string
}

// newCoinbaseClient will populate the client auth credietions directly
func newCoinbaseClient(key, passphrase, secret, url string) *C {
	c := new(C)
	c.key = key
	c.passphrase = passphrase
	c.secret = secret
	c.url = url
	return c
}

// newCoinbaseClientEnv will populate the client auth credentials using a
// .env file
func newCoinbaseClientEnv() *C {
	c := new(C)
	c.key = env.CoinbaseProAccessKey.Get()
	c.passphrase = env.CoinbaseProAccessPassphrase.Get()
	c.secret = env.CoinbaseProSecret.Get()
	c.url = env.CoinbaseProURL.Get()
	return c
}

// DefaultConnector will pull the coinbase authentication data from the env
// variables.  See README for more information on how to set these up.
func DefaultConnector() (client.C, error) {
	c := newCoinbaseClientEnv()
	return c, nil
}

// NewAccounts will return a new accounts structure to query on trading accounts
func NewClient(conn client.Connector) *C {
	coinbaseClient := new(C)
	client.ConstructParent(&coinbaseClient.Parent, conn)
	return coinbaseClient
}

func NewClientEnv(envFilepath string) *C {
	env.Load(envFilepath)
	coinbaseClient := new(C)
	client.ConstructParent(&coinbaseClient.Parent, DefaultConnector)
	return coinbaseClient
}

// NewWebsocket will create a connection to the coinbase websocket and
// return a singleton that can be used to open channels that stream product
// data via a websocket.
func NewWebsocket(ws websocket.Creator) *ProductWebsocket {
	productWebsocket := new(ProductWebsocket)
	productWebsocket.conn, _ = ws(websocketURL)
	return productWebsocket
}

// generateSig generates the coinbase base64-encoded signature required to make
// requests.  In particular, the coinbaseClient-ACCESS-SIGN header is generated by creating
// a sha256 HMAC using the base64-decoded secret key on the prehash string
// timestamp + method + requestPath + body (where + represents string
// concatenation) and base64-encode the output. The timestamp value is the same
// as the coinbaseClient-ACCESS-TIMESTAMP header.
func (coinbaseClient *C) generateSig(secret, message string) (string, error) {
	key, err := base64.StdEncoding.DecodeString(secret)
	if err != nil {
		return "", err
	}

	signature := hmac.New(sha256.New, key)
	_, err = signature.Write([]byte(message))
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(signature.Sum(nil)), nil
}

// generageMsg makes the message to be signed
func (coinbaseClient *C) generageMsg(creq client.Request, timestamp string) string {
	return fmt.Sprintf("%s%s%s%s", timestamp, creq.MethodStr(), creq.URIPostAuthority(), string(creq.GetBody().Bytes()))
}

// setHeaders sets the headers for a coinbase api request, in particular:
//
// - coinbaseClient-ACCESS-KEY The api key as a string.
// - coinbaseClient-ACCESS-SIGN The base64-encoded signature (see Signing a Message).
// - coinbaseClient-ACCESS-TIMESTAMP A timestamp for your request.
// - coinbaseClient-ACCESS-PASSPHRASE The passphrase you specified when creating the API key.
func (coinbaseClient *C) setHeaders(hreq *http.Request, creq client.Request) (e error) {
	// TODO depricate getting key/passphrase/secret with secret keeper
	var (
		timestamp = strconv.FormatInt(time.Now().Unix(), 10)
		msg       = coinbaseClient.generageMsg(creq, timestamp)
	)

	var sig string
	sig, e = coinbaseClient.generateSig(coinbaseClient.secret, msg)
	hreq.Header.Add("accept", "application/json")
	hreq.Header.Add("content-type", "application/json")
	hreq.Header.Add("cb-access-key", coinbaseClient.key)
	hreq.Header.Add("cb-access-passphrase", coinbaseClient.passphrase)
	hreq.Header.Add("cb-access-sign", sig)
	hreq.Header.Add("cb-access-timestamp", timestamp)

	// TODO wrap this in a logger
	logMsg := `{Client:{Access:{Key:%s,Passphrase:%s,Timestamp:%s,Sign:%s}}}`
	client.Logf(log.DEBUG, &creq, logMsg, coinbaseClient.key, coinbaseClient.passphrase, timestamp, sig)
	return
}

// request makes an http request to the coinbase api, given a method and an endpoint.
func (coinbaseClient *C) Do(creq client.Request) (*http.Response, error) {
	// TODO make data-compatible for non-get requests
	uri := coinbaseClient.url + creq.URIPostAuthority()

	client.Logf(log.DEBUG, &creq, `{Client:{URI:%s}}`, uri)

	hreq, err := http.NewRequest(creq.MethodStr(), uri, bytes.NewReader(creq.GetBody().Bytes()))
	if err != nil {
		return nil, err
	}
	if err := coinbaseClient.setHeaders(hreq, creq); err != nil {
		return nil, err
	}
	return coinbaseClient.client.Do(hreq)
}

// Connect creats a new client instance
func (coinbaseClient *C) Connect() error {
	coinbaseClient.client = http.Client{}
	return nil
}

// Identifier identifies requests
func (coinbaseClient *C) Identifier() string {
	return "Coinbase Pro"
}
