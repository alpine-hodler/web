package coinbasepro

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/alpine-hodler/sdk/internal/client"
	"github.com/alpine-hodler/sdk/internal/env"
	"github.com/alpine-hodler/sdk/internal/log"
	"github.com/alpine-hodler/sdk/pkg/websocket"
)

// C is the coinbase pro client
type C struct {
	client.Parent

	client     http.Client
	key        string
	passphrase string
	secret     string
	url        string
}

const (
	// Some dumbass coinbase thing
	coinbaseTimeLayout1 = "2006-01-02 15:04:05.999999999+00"

	websocketURL = "wss://ws-feed.pro.coinbase.com"
)

func (c *C) SetKey(key string)               { c.key = key }
func (c *C) SetPassphrase(passphrase string) { c.passphrase = passphrase }
func (c *C) SetSecret(secret string)         { c.secret = secret }
func (c *C) SetURL(url string)               { c.url = url }

// newCoinbaseClientEnv will populate the client auth credentials using a
// .env file
func newCoinbaseClientEnv() *C {
	c := new(C)
	c.key = env.CoinbaseProAccessKey.Get()
	c.passphrase = env.CoinbaseProAccessPassphrase.Get()
	c.secret = env.CoinbaseProSecret.Get()
	c.url = env.CoinbaseProURL.Get()
	return c
}

// DefaultConnector will pull the coinbase authentication data from the env
// variables.  See README for more information on how to set these up.
func DefaultConnector() (client.C, error) {
	c := newCoinbaseClientEnv()
	return c, nil
}

// NewAccounts will return a new accounts structure to query on trading accounts
func NewClient(conn client.Connector) *C {
	c := new(C)
	client.ConstructParent(&c.Parent, conn)
	return c
}

func NewClientEnv(envFilepath string) *C {
	env.Load(envFilepath)
	c := new(C)
	client.ConstructParent(&c.Parent, DefaultConnector)
	return c
}

// NewWebsocket will create a connection to the coinbase websocket and
// return a singleton that can be used to open channels that stream product
// data via a websocket.
func NewWebsocket(ws websocket.Creator) *ProductWebsocket {
	productWebsocket := new(ProductWebsocket)
	productWebsocket.conn, _ = ws(websocketURL)
	return productWebsocket
}

// generateSig generates the coinbase base64-encoded signature required to make
// requests.  In particular, the c-ACCESS-SIGN header is generated by creating
// a sha256 HMAC using the base64-decoded secret key on the prehash string
// timestamp + method + requestPath + body (where + represents string
// concatenation) and base64-encode the output. The timestamp value is the same
// as the c-ACCESS-TIMESTAMP header.
func (c *C) generateSig(secret, message string) (string, error) {
	key, err := base64.StdEncoding.DecodeString(secret)
	if err != nil {
		return "", err
	}

	signature := hmac.New(sha256.New, key)
	_, err = signature.Write([]byte(message))
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(signature.Sum(nil)), nil
}

// generageMsg makes the message to be signed
func (c *C) generageMsg(creq client.Request, timestamp string) string {
	return fmt.Sprintf("%s%s%s%s", timestamp, creq.MethodStr(), creq.URIPostAuthority(), string(creq.GetBody().Bytes()))
}

// setHeaders sets the headers for a coinbase api request, in particular:
//
// - c-ACCESS-KEY The api key as a string.
// - c-ACCESS-SIGN The base64-encoded signature (see Signing a Message).
// - c-ACCESS-TIMESTAMP A timestamp for your request.
// - c-ACCESS-PASSPHRASE The passphrase you specified when creating the API key.
func (c *C) setHeaders(hreq *http.Request, creq client.Request) (e error) {
	var (
		timestamp = strconv.FormatInt(time.Now().Unix(), 10)
		msg       = c.generageMsg(creq, timestamp)
	)

	var sig string
	sig, e = c.generateSig(c.secret, msg)
	hreq.Header.Add("accept", "application/json")
	hreq.Header.Add("content-type", "application/json")
	hreq.Header.Add("cb-access-key", c.key)
	hreq.Header.Add("cb-access-passphrase", c.passphrase)
	hreq.Header.Add("cb-access-sign", sig)
	hreq.Header.Add("cb-access-timestamp", timestamp)

	logMsg := `{Client:{Access:{Key:%s,Passphrase:%s,Timestamp:%s,Sign:%s}}}`
	client.Logf(log.DEBUG, &creq, logMsg, c.key, c.passphrase, timestamp, sig)
	return
}

// request makes an http request to the coinbase api, given a method and an endpoint.
func (c *C) Do(creq client.Request) (*http.Response, error) {
	uri := c.url + creq.URIPostAuthority()

	client.Logf(log.DEBUG, &creq, `{Client:{URI:%s}}`, uri)

	hreq, err := http.NewRequest(creq.MethodStr(), uri, bytes.NewReader(creq.GetBody().Bytes()))
	if err != nil {
		return nil, err
	}
	if err := c.setHeaders(hreq, creq); err != nil {
		return nil, err
	}
	return c.client.Do(hreq)
}

// Connect creats a new client instance
func (c *C) Connect() error {
	c.client = http.Client{}
	return nil
}

// Identifier identifies requests
func (c *C) Identifier() string {
	return "Coinbase Pro"
}
